# -*- coding: utf-8 -*-
"""8 Queens Problem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JpEV17gVFomTl-BixU8aNgcs6WOzbTOm

State: [0,4,7,5,2,6,1,3] -- index is the column number and the value at that index is the row number

Goal: No queen should be attacking each other (num_attacks() = 0)

Actions: Move to different row in its column

## Hill Climbing Algorithm
"""

# import random

# N = 8  # 8 queens

# def random_board():
#     return [random.randint(0, N - 1) for _ in range(N)]

# def get_conflicts(board):
#     conflicts = 0
#     for i in range(N):
#         for j in range(i + 1, N):
#             if board[i] == board[j] or abs(board[i] - board[j]) == abs(i - j):
#                 conflicts += 1
#     return conflicts

# def get_best_neighbor(board):
#     min_conflicts = get_conflicts(board)
#     best_board = board[:]

#     for col in range(N):
#         original_row = board[col]
#         for row in range(N):
#             if row != original_row:
#                 board[col] = row
#                 conflicts = get_conflicts(board)
#                 if conflicts < min_conflicts:
#                     min_conflicts = conflicts
#                     best_board = board[:]
#         board[col] = original_row

#     return best_board, min_conflicts

# def print_board(board):
#     for row in range(N):
#         line = ""
#         for col in range(N):
#             line += "Q " if board[col] == row else ". "
#         print(line)
#     print()

# def hill_climbing():
#     board = random_board()
#     step = 0
#     current_conflicts = get_conflicts(board)

#     print(f"Step {step}: Conflicts = {current_conflicts}")
#     print_board(board)

#     while True:
#         next_board, next_conflicts = get_best_neighbor(board)
#         if current_conflicts <= next_conflicts:
#             # Local minimum or goal
#             break
#         board = next_board
#         current_conflicts = next_conflicts
#         step += 1
#         print(f"Step {step}: Conflicts = {current_conflicts}")
#         print_board(board)

#     return board, current_conflicts, step

# # Run it
# solution, conflicts, steps = hill_climbing()

# print("Final Board:")
# print_board(solution)
# print(f"Final Conflicts: {conflicts}")
# print(f"Total Steps: {steps+1}")

import random
import time
import tracemalloc

N = 8  # number of queens

# Utility to print the board
def print_board(state):
    for row in range(N):
        line = ""
        for col in range(N):
            if state[col] == row:
                line += "Q "
            else:
                line += ". "
        print(line)
    print("\n")

# Number of pairs of queens attacking each other
def compute_conflicts(state):
    conflicts = 0
    for i in range(N):
        for j in range(i + 1, N):
            if state[i] == state[j] or abs(state[i] - state[j]) == abs(i - j):
                conflicts += 1
    return conflicts

# Get neighbor with the least conflicts
def get_best_neighbor(state):
    min_conflicts = compute_conflicts(state)
    best_state = list(state)

    for col in range(N):
        original_row = state[col]
        for row in range(N):
            if row != original_row:
                neighbor = list(state)
                neighbor[col] = row
                score = compute_conflicts(neighbor)
                if score < min_conflicts:
                    min_conflicts = score
                    best_state = neighbor
    return best_state

def hill_climbing_until_success():
    total_steps = 0
    restarts = 0

    while True:
        current = [random.randint(0, N - 1) for _ in range(N)]
        steps = 0

        while True:
            print(f"Restart {restarts}, Step {steps} - Conflicts: {compute_conflicts(current)}")
            print_board(current)

            neighbor = get_best_neighbor(current)

            if compute_conflicts(neighbor) >= compute_conflicts(current):
                break  # local minimum reached

            current = neighbor
            steps += 1

        total_steps += steps
        restarts += 1

        if compute_conflicts(current) == 0:
            print(f"Solution found after {restarts} restarts and {total_steps} total steps!")
            print_board(current)
            return restarts, total_steps


def evaluate_hill_climbing():
    tracemalloc.start()
    start_time = time.time()

    restarts, total_steps = hill_climbing_until_success()

    end_time = time.time()
    current, peak = tracemalloc.get_traced_memory()
    tracemalloc.stop()

    print("----- Final Performance Summary -----")
    print(f"Restarts: {restarts}")
    print(f"Total Steps: {total_steps}")
    print(f"Total Time (s): {end_time - start_time:.4f}")
    print(f"Peak Memory Usage (bytes): {peak}")
    print("Time Complexity: Empirical ~ O(n^2)")
    print("Space Complexity: Empirical ~ O(n)")


evaluate_hill_climbing()

"""## Genetic Algorithm"""

# import random

# # Set seed for consistent results every time
# random.seed(42)

# # Config
# N = 8
# POP_SIZE = 100
# MUTATION_RATE = 0.02  # Lower for stability

# def random_board():
#     return [random.randint(0, N - 1) for _ in range(N)]

# def get_conflicts(board):
#     conflicts = 0
#     for i in range(N):
#         for j in range(i + 1, N):
#             if board[i] == board[j] or abs(board[i] - board[j]) == abs(i - j):
#                 conflicts += 1
#     return conflicts

# def fitness(board):
#     max_conflicts = (N * (N - 1)) // 2
#     return max_conflicts - get_conflicts(board)

# def select_parents(population):
#     tournament = random.sample(population, 5)
#     tournament.sort(key=lambda b: fitness(b), reverse=True)
#     return tournament[0], tournament[1]

# def crossover(parent1, parent2):
#     point = random.randint(1, N - 2)
#     return parent1[:point] + parent2[point:]

# def mutate(board):
#     if random.random() < MUTATION_RATE:
#         col = random.randint(0, N - 1)
#         board[col] = random.randint(0, N - 1)
#     return board

# def print_board(board):
#     for row in range(N):
#         line = ""
#         for col in range(N):
#             line += "Q " if board[col] == row else ". "
#         print(line)
#     print()

# def genetic_algorithm_with_steps():
#     population = [random_board() for _ in range(POP_SIZE)]
#     best_board = min(population, key=get_conflicts)
#     best_conflicts = get_conflicts(best_board)

#     step = 0
#     print(f"Step {step}: Conflicts = {best_conflicts}")
#     print_board(best_board)

#     while best_conflicts > 0:
#         step += 1

#         # Keep top 20 best boards (elitism)
#         population.sort(key=lambda b: fitness(b), reverse=True)
#         next_gen = population[:10]

#         # Fill the rest of the population with babies
#         while len(next_gen) < POP_SIZE:
#             parent1, parent2 = select_parents(population)
#             child = crossover(parent1, parent2)
#             child = mutate(child)
#             next_gen.append(child)

#         population = next_gen
#         current_best = min(population, key=get_conflicts)
#         current_conflicts = get_conflicts(current_best)

#         if current_conflicts < best_conflicts:
#             best_board = current_best
#             best_conflicts = current_conflicts
#             print(f"Step {step}: Conflicts = {best_conflicts}")
#             print_board(best_board)

#     print("Final Board:")
#     print_board(best_board)
#     print(f"Final Conflicts: {best_conflicts}")
#     print(f"Total Steps: {step}")

#     return best_board

# # Run it
# genetic_algorithm_with_steps()

import random
import time
import tracemalloc

# Set seed for consistent results every time
random.seed(42)

# Config
N = 8
POP_SIZE = 100
MUTATION_RATE = 0.02


def random_board():
    return [random.randint(0, N - 1) for _ in range(N)]

def get_conflicts(board):
    conflicts = 0
    for i in range(N):
        for j in range(i + 1, N):
            if board[i] == board[j] or abs(board[i] - board[j]) == abs(i - j):
                conflicts += 1
    return conflicts

def fitness(board):
    max_conflicts = (N * (N - 1)) // 2
    return max_conflicts - get_conflicts(board)

def select_parents(population):
    tournament = random.sample(population, 5)
    tournament.sort(key=lambda b: fitness(b), reverse=True)
    return tournament[0], tournament[1]

def crossover(parent1, parent2):
    point = random.randint(1, N - 2)
    return parent1[:point] + parent2[point:]

def mutate(board):
    if random.random() < MUTATION_RATE:
        col = random.randint(0, N - 1)
        board[col] = random.randint(0, N - 1)
    return board

def print_board(board):
    for row in range(N):
        line = ""
        for col in range(N):
            line += "Q " if board[col] == row else ". "
        print(line)
    print()

def genetic_algorithm_with_steps():
    population = [random_board() for _ in range(POP_SIZE)]
    best_board = min(population, key=get_conflicts)
    best_conflicts = get_conflicts(best_board)

    step = 0
    print(f"Step {step}: Conflicts = {best_conflicts}")
    print_board(best_board)

    tracemalloc.start()
    start_time = time.time()

    while best_conflicts > 0:
        step += 1

        population.sort(key=lambda b: fitness(b), reverse=True)
        next_gen = population[:10]

        while len(next_gen) < POP_SIZE:
            parent1, parent2 = select_parents(population)
            child = crossover(parent1, parent2)
            child = mutate(child)
            next_gen.append(child)

        population = next_gen
        current_best = min(population, key=get_conflicts)
        current_conflicts = get_conflicts(current_best)

        if current_conflicts < best_conflicts:
            best_board = current_best
            best_conflicts = current_conflicts
            print(f"Step {step}: Conflicts = {best_conflicts}")
            print_board(best_board)

    total_time = time.time() - start_time
    current, peak = tracemalloc.get_traced_memory()
    tracemalloc.stop()

    print("Final Board:")
    print_board(best_board)
    print(f"Final Conflicts: {best_conflicts}")
    print(f"Restarts: 1")
    print(f"Total Steps: {step}")
    print(f"Total Time (s): {total_time:.4f}")
    print(f"Peak Memory Usage (bytes): {peak}")

    return best_board

# Run it
genetic_algorithm_with_steps()

# Results with different seed and next_gen
# seed: 42, next_gen: [:20] --> 106
# seed: 42, next_gen: [:10] --> 36
# seed: 42, next_gen: [:5] --> 62
# seed: 20, next_gen: [:20] --> 315
# seed: 60, next_gen: [:20] --> took too long to run
# seed: 60, next_gen: [:10] --> took too long to run
# seed: 30, next_gen: [:]

"""## Simulated Annealing algorithm"""

import random
import math
import time
import tracemalloc

N = 8

def random_state():
    return [random.randint(0, N - 1) for _ in range(N)]

def calculate_conflicts(state):
    conflicts = 0
    for i in range(N):
        for j in range(i + 1, N):
            if state[i] == state[j] or abs(state[i] - state[j]) == abs(i - j):
                conflicts += 1
    return conflicts

def print_board(state, step, conflicts):
    print(f"\nStep {step}: Conflicts = {conflicts}")
    for row in range(N):
        line = ""
        for col in range(N):
            line += "Q " if state[row] == col else ". "
        print(line.strip())

def get_neighbor(state):
    neighbor = state[:]
    row = random.randint(0, N - 1)
    col = random.randint(0, N - 1)
    while col == state[row]:
        col = random.randint(0, N - 1)
    neighbor[row] = col
    return neighbor

def simulated_annealing(track=False):
    current = random_state()
    current_conflicts = calculate_conflicts(current)
    T = 100.0
    T_min = 1e-4
    alpha = 0.99
    step = 0
    steps_logged = []

    if track:
        print_board(current, step, current_conflicts)

    while T > T_min and current_conflicts > 0:
        for _ in range(100):
            neighbor = get_neighbor(current)
            neighbor_conflicts = calculate_conflicts(neighbor)
            delta = current_conflicts - neighbor_conflicts
            if delta > 0 or math.exp(delta / T) > random.random():
                current = neighbor
                current_conflicts = neighbor_conflicts
                step += 1
                if track:
                    print_board(current, step, current_conflicts)
                steps_logged.append((step, current_conflicts, current[:]))
                if current_conflicts == 0:
                    break
        T *= alpha

    return {
        "final_state": current,
        "final_conflicts": current_conflicts,
        "steps": step,
        "steps_logged": steps_logged,
        "is_solution": current_conflicts == 0
    }

def evaluate_algorithm(algo_fn, name="Simulated Annealing", trials=5, track_one=False):
    import statistics

    print(f"\nEvaluating: {name} 🔍")
    times = []
    steps_list = []
    solutions = 0
    mem_usages = []

    for i in range(trials):
        tracemalloc.start()
        start_time = time.time()
        result = algo_fn(track=(track_one and i == 0))
        end_time = time.time()
        mem, _ = tracemalloc.get_traced_memory()
        tracemalloc.stop()

        times.append(end_time - start_time)
        steps_list.append(result["steps"])
        mem_usages.append(mem / 1024)  # KB

        if result["is_solution"]:
            solutions += 1

    print(f"\nResults for {name}:")
    print(f"Completeness: {solutions}/{trials} solutions found")
    print(f"Cost Optimality: All solutions have 0 conflicts? {'Yes' if solutions == trials else 'No'}")
    print(f"Avg Time: {statistics.mean(times):.4f} sec")
    print(f"Avg Steps: {statistics.mean(steps_list):.1f} moves")
    print(f"Peak Memory: {max(mem_usages):.2f} KB")


sa_result = evaluate_algorithm(simulated_annealing, track_one=True)

