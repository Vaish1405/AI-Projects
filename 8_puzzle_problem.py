# -*- coding: utf-8 -*-
"""Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D_bwEERIh2wwlPWkLZ0LF8Lnj3lo0-7E

#Google Colab Implementation of the 8-puzzle Problem

##Define the State Represnetaion
"""

from types import new_class

class StatePuzzle:
  def __init__(self, board, parent=None, move=None, depth=0):
    self.board = board
    self.parent = parent
    self.move = move
    self.depth = depth
    self.blank_position = self.find_blank()

  def find_blank(self):
    # Seaching in a 3x3 grid
    for y in range(3):
      for x in range(3):
        if self.board[y][x] == 0: # 0 position is a blank position
          return x, y # Return (column, row)

    raise ValueError("Error: No blank tile (0) found in the board!")

  def possible_moves(self):
    moves = []
    x, y = self.blank_position

    # case when the blank tile is not in the most right column
    if x > 0: moves.append("left")

    # case when the blank tile is not in the most left column
    if x < 2: moves.append("right")

    # case when the blank tile is not in the first row
    if y > 0: moves.append("up")

    # case when the blank tile is not in the last row
    if y < 2: moves.append("down")

    return moves

  def apply_move(self, move):
    x, y = self.blank_position # x = column, y = row
    new_board = [row[:] for row in self.board] # create a copy of the board

    if move == "up":
      # Swap the blank with tile above
      new_board[y][x], new_board[y-1][x] = new_board[y-1][x], new_board[y][x]

      """
      The code above is the shortcut that is equivalen to:
      temp = new_board[y][x]      # Store blank tile (0)
      new_board[y][x] = new_board[y-1][x]  # Move the upper tile down
      new_board[y-1][x] = temp  # Move blank tile (0) up
      """
      new_blank_position = (x, y-1)

    elif move == "down":
      # Swap the blank with tile below
      new_board[y][x], new_board[y+1][x] = new_board[y+1][x], new_board[y][x]
      new_blank_position = (x, y+1)

    elif move == "left":
      # Swap the blank with tile on the left
      new_board[y][x], new_board[y][x-1] = new_board[y][x-1], new_board[y][x]
      new_blank_position = (x-1, y)

    elif move == "right":
      # Swap the blank with tile on the right
      new_board[y][x], new_board[y][x+1] = new_board[y][x+1], new_board[y][x]
      new_blank_position = (x+1, y)

    new_state = StatePuzzle(new_board, self, move, self.depth + 1)
    new_state.blank_position = new_blank_position  # Assign the updated blank position
    return new_state

"""##Error Handling"""

def is_valid_board(board):

    if len(board) != 3 or any(len(row) != 3 for row in board):
        raise ValueError("Invalid board size: The board must be 3x3.")

    flat_board = [num for row in board for num in row]
    if sorted(flat_board) != list(range(9)):
        raise ValueError("Invalid board: The board must contain numbers 0-8 without duplicates.")

"""##Test Cases & Performance Measurement"""

def solution_check(board, goal_board):
    ''' Summary
    -----------------------------------------------------------------------------
    In the 8 puzzle problem odd inversion counts indicate an unsolvable state we can leverage this to detect unsolvable cases. The reason why largely has to do with corners being inaccessible for swaps, if you work out a simple one
    on paper it becomes easy to tell. Try 123456780 --> 123456870 for instance. This definition takes two parameters the board itself and its goal state, we need both since we arent going in sequential order as is usual for
    this problem set. Our first step (mainly to keep things simple) is to flatten out both our goal and our board we ignore the 0 since its an empty space and thus irrelevant to the swaps. We have to keep in mind the relative
    positions in the goal state though which is documented in mapped_positions, from here we simply check the indices recursively and see if our mapped positions are out of alignment and require swaps. It is important to note
    I am checking if the position is greater removing the need for duplicate checking via sets or dictionaries. We modulate by 2 to see if the number is odd.
    '''
    # Flatten our goal and board
    flattened = [tile for row in board for tile in row if tile != 0]
    goal_flattened = [tile for row in goal_board for tile in row if tile != 0]

    # document positions of tiles in goal and store their mappings
    goal_positions = {tile: idx for idx, tile in enumerate(goal_flattened)}
    mapped_positions = [goal_positions[tile] for tile in flattened]

    # Instantiations
    swaps = 0

    # Recursively check for inversions
    for i in range(len(mapped_positions)):
        for j in range(i + 1, len(mapped_positions)):
            if mapped_positions[i] > mapped_positions[j]:
                swaps += 1
    # Return boolean true if even
    return swaps % 2 == 0

test_cases_1 = [
    {"name": "Trivial Case", "board": [[1, 2, 3], [4, 5, 6], [7, 8, 0]]},
    {"name": "Case 1", "board": [[1, 2, 3], [4, 5, 6], [0, 7, 8]]},
    {"name": "Case 2", "board": [[1, 2, 3], [0, 5, 6], [4, 7, 8]]},
    {"name": "Case 3", "board": [[1, 2, 3], [5, 0, 6], [4, 7, 8]]},
    {"name": "Case 4", "board": [[0, 1, 3], [4, 2, 5], [7, 8, 6]]},
    {"name": "Case 5", "board": [[1, 0, 3], [4, 2, 5], [7, 8, 6]]},
    {"name": "Case 6", "board": [[1, 2, 3], [4, 5, 0], [7, 8 ,6]]},
    {"name": "Unsolvable Case", "board": [[1, 2, 3], [4, 5, 6], [8, 7, 0]]}, # Unsolvable due to inversion
]

test_cases_2 = [
    {"name": "Case 1", "board": [[1, 3, 4], [8, 0, 5], [7, 2, 6]]},
    {"name": "Case 2", "board": [[1, 3, 4], [8, 6, 2], [0, 7, 5]]},
    {"name": "Case 3", "board": [[3, 6, 4], [0 ,1, 2], [8, 7, 5]]},
    {"name": "Case 4", "board": [[2, 3, 1], [7, 0, 8], [6, 5, 4]]},
    {"name": "Case 5", "board": [[2, 3, 1], [8, 0, 4], [7, 6, 5]]},
    {"name": "Case 6", "board": [[8, 7, 6], [1, 0 ,5], [2, 3, 4]]}
]

test_cases_3 = [
    {"name": "Case 1", "board": [[8, 0, 6], [5, 4, 7], [2, 3, 1]]},
    {"name": "Case 2", "board": [[6, 4, 1], [3, 0, 2], [7, 5, 8]]},
    {"name": "Case 3", "board": [[1, 5, 8], [3, 2, 7], [0, 6, 4]]},
    {"name": "Case 4", "board": [[3, 2, 8], [4, 5, 1], [6, 7, 0]]},
    {"name": "Case 5", "board": [[7, 2, 5], [3, 1, 0], [6, 4, 8]]},
    {"name": "Case 6", "board": [[0, 3, 5], [4, 2, 8], [6, 1, 7]]}
]

goal_board_1 = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
goal_board_2 = [[1, 2, 3], [8, 0, 4], [7, 6, 5]]
goal_board_3 = [[0, 1, 2], [3, 4, 5], [6, 7, 8]]


challenge_cases_1 = [
    {"name": "Challenge 1", "board": [[8, 6, 7], [2, 5, 4], [3, 0, 1]]},
    {"name": "Challenge 2", "board": [[6, 4, 7], [8, 5, 0], [3, 2, 1]]},
    {"name": "Challenge 3", "board": [[4, 1, 2], [0, 8, 7], [6, 3, 5]]},
    {"name": "Challenge 4", "board": [[1, 6, 2], [5, 7, 3], [0, 4, 8]]}
]

# Document our test cases
allcases = test_cases_1 + test_cases_2 + test_cases_3 + challenge_cases_1

# Call through our documented cases and cross reference them with the relevant goal boards
for case in allcases:
  name = case["name"]
  board = case["board"]
  if case in test_cases_1:
        goal_board = goal_board_1
  elif case in test_cases_2:
        goal_board = goal_board_2
  elif case in test_cases_3:
        goal_board = goal_board_3
  else:
        goal_board = goal_board_1
  # Set a variable status to document the solution status via solution_check
  status = "This puzzle can be solved!" if solution_check(board,goal_board) else "This puzzle cannot be solved :("

  # Print the name and status of the puzzles solvability you can delete this if you would like
  print(f"{name}: {status}")

import time

def run_test_1(search_algo):
  for test in test_cases_1:
    print(f"Running {test['name']}:")
    initial_state = StatePuzzle(test['board'])

    start_time = time.time()
    solution, nodes_explored = search_algo(initial_state, goal_board_1)
    end_time = time.time()

    if solution is not None:
      print(f"Solution found in {len(solution)} moves: {solution}")
    else:
      print("No solution found.")

    print(f"Execution Time: {end_time - start_time:.4f} seconds")
    print(f"Nodes Explored: {nodes_explored}\n")

def run_test_2(search_algo):
  for test in test_cases_2:
    print(f"Running {test['name']}:")
    initial_state = StatePuzzle(test['board'])

    start_time = time.time()
    solution, nodes_explored = search_algo(initial_state, goal_board_2)
    end_time = time.time()

    if solution is not None:
      print(f"Solution found in {len(solution)} moves: {solution}")
    else:
      print("No solution found.")

    print(f"Execution Time: {end_time - start_time:.4f} seconds")
    print(f"Nodes Explored: {nodes_explored}\n")

def run_test_3(search_algo):
  for test in test_cases_3:
    print(f"Running {test['name']}:")
    initial_state = StatePuzzle(test['board'])

    start_time = time.time()
    solution, nodes_explored = search_algo(initial_state, goal_board_3)
    end_time = time.time()

    if solution is not None:
      print(f"Solution found in {len(solution)} moves: {solution}")
    else:
      print("No solution found.")

    print(f"Execution Time: {end_time - start_time:.4f} seconds")
    print(f"Nodes Explored: {nodes_explored}\n")

def run_challenge_test_1(search_algo):
  for test in challenge_cases_1:
    print(f"Running {test['name']}:")
    initial_state = StatePuzzle(test['board'])

    start_time = time.time()
    solution, nodes_explored = search_algo(initial_state, goal_board_1)
    end_time = time.time()

    if solution is not None:
      print(f"Solution found in {len(solution)} moves: {solution}")
    else:
      print("No solution found.")

    print(f"Execution Time: {end_time - start_time:.4f} seconds")
    print(f"Nodes Explored: {nodes_explored}\n")

"""##Utility Function(s)"""

def get_solution_path(state):
  # Backtracks from thje goal stgate to retrieve the move sequence
  path = []
  while state.parent:
    path.append(state.move)
    state = state.parent
  return path[::-1]

"""##Breath-First Search (BFS)"""

from collections import deque

def bfs(initial_state, goal_state):

    try:
        is_valid_board(initial_state.board)  # Validate board before searching
    except ValueError as e:
        print(f"Error: {e}")
        return None, 0

    visited = set()  # Use a set instead of a dict
    queue = deque([initial_state])
    nodes_explored = 0

    while queue:
        state = queue.popleft()
        nodes_explored += 1
        state_tuple = tuple(map(tuple, state.board))

        if state_tuple in visited:
            continue
        visited.add(state_tuple)  # Mark state as visited

        # Goal Check
        if state.board == goal_state:
            return get_solution_path(state), nodes_explored  # Return shortest path

        # Expand the state by applying all possible moves
        for move in state.possible_moves():
            new_state = state.apply_move(move)
            new_state_tuple = tuple(map(tuple, new_state.board))

            if new_state_tuple not in visited:  # Avoid revisiting states
                queue.append(new_state)

    return None, nodes_explored  # No solution found

run_test_1(bfs)

run_test_2(bfs)

run_test_3(bfs)

run_challenge_test_1(bfs)

"""##Depth-First Search"""

def dfs(initial_state, goal_state, max_depth=50):

    try:
        is_valid_board(initial_state.board)  # Validate the board before proceeding
    except ValueError as e:
        print(f"Error: {e}")
        return None, 0

    visited = set()
    stack = [(initial_state, 0)]  # Stack now holds (state, depth)
    nodes_explored = 0

    while stack:
        state, depth = stack.pop()
        nodes_explored += 1

        # Convert board state to a hashable tuple
        state_tuple = tuple(map(tuple, state.board))
        if state_tuple in visited or depth > max_depth:  # Depth limit check
            continue
        visited.add(state_tuple)

        # Goal Check
        if state.board == goal_state:
            return get_solution_path(state), nodes_explored

        # Expand the state by applying all possible moves
        for move in reversed(state.possible_moves()):  # Reverse for correct DFS order
            new_state = state.apply_move(move)
            stack.append((new_state, depth + 1))  # Track depth

    return None, nodes_explored  # No solution found

run_test_1(dfs)

run_test_2(bfs)

run_test_3(bfs)

run_challenge_test_1(bfs)

"""##A* Search Algorithm"""

import heapq
from itertools import count  # To generate unique tie-breaker values

def manhattan_distance(board, goal):

    # Calculate Manhattan distance for all misplaced tiles
    distance = 0
    goal_flat = [num for row in goal for num in row]  # Flatten goal state

    for y in range(3):
        for x in range(3):
            if board[y][x] != 0:  # Ignore blank tile
                goal_index = goal_flat.index(board[y][x])  # Find correct position in goal
                goal_x, goal_y = divmod(goal_index, 3)  # Convert index to row/col
                distance += abs(goal_x - x) + abs(goal_y - y)

    return distance

def a_star(initial_state, goal_state):

    try:
        is_valid_board(initial_state.board)  # Validate board before searching
    except ValueError as e:
        print(f"Error: {e}")
        return None, 0

    priority_queue = []
    visited = {}
    counter = count()  # Unique counter to avoid comparison errors

    # Convert goal state to a list for indexing
    goal_flat = [num for row in goal_state for num in row]

    # Push the initial state with priority based on heuristic
    heapq.heappush(priority_queue, (0, next(counter), initial_state))
    nodes_explored = 0

    while priority_queue:
        _, _, state = heapq.heappop(priority_queue)  # Extract state
        nodes_explored += 1

        state_tuple = tuple(map(tuple, state.board))
        if state_tuple in visited and visited[state_tuple] <= state.depth:
            continue
        visited[state_tuple] = state.depth

        # Goal Check
        if state.board == goal_state:
            return get_solution_path(state), nodes_explored

        for move in state.possible_moves():
            new_state = state.apply_move(move)
            new_state_tuple = tuple(map(tuple, new_state.board))

            if new_state_tuple not in visited or visited[new_state_tuple] > new_state.depth:
                priority = new_state.depth + manhattan_distance(new_state.board, goal_state)
                heapq.heappush(priority_queue, (priority, next(counter), new_state))  # Use counter for uniqueness

    return None, nodes_explored  # No solution found

run_test_1(a_star)

run_test_2(a_star)

run_test_3(a_star)

run_challenge_test_1(a_star)

"""##Greedy Best-First"""

import heapq
from itertools import count  # To generate unique tie-breaker values

def greedy_best_first(initial_state, goal_state):

    try:
        is_valid_board(initial_state.board)  # Validate board before searching
    except ValueError as e:
        print(f"Error: {e}")
        return None, 0

    priority_queue = []
    visited = set()
    counter = count()  # Unique counter to avoid TypeError in heapq

    # Push initial state with heuristic priority
    heapq.heappush(priority_queue, (manhattan_distance(initial_state.board, goal_state), next(counter), initial_state))
    nodes_explored = 0

    while priority_queue:
        _, _, state = heapq.heappop(priority_queue)  # Extract state
        nodes_explored += 1

        state_tuple = tuple(map(tuple, state.board))
        if state_tuple in visited:
            continue
        visited.add(state_tuple)

        # Goal Check
        if state.board == goal_state:
            return get_solution_path(state), nodes_explored

        # Expand the state by applying all possible moves
        for move in state.possible_moves():
            new_state = state.apply_move(move)
            new_state_tuple = tuple(map(tuple, new_state.board))

            if new_state_tuple not in visited:
                priority = manhattan_distance(new_state.board, goal_state)
                heapq.heappush(priority_queue, (priority, next(counter), new_state))  # Counter ensures uniqueness

    return None, nodes_explored  # No solution found

run_test_1(greedy_best_first)

run_test_2(greedy_best_first)

run_test_3(greedy_best_first)

run_challenge_test_1(greedy_best_first)

"""##Iterative Deepening Search(IDS) or Iterative Deepening Depth First Search(IDDFS)"""

def depth_limited_search(state, goal_state, depth_limit, visited):
    """Performs Depth-Limited DFS to avoid deep, unnecessary searches."""
    if state.board == goal_state:
        return get_solution_path(state), 1  # Found solution

    if depth_limit == 0:
        return None, 1  # Reached depth limit, stop further search

    state_tuple = tuple(map(tuple, state.board))
    visited.add(state_tuple)  # Mark state as visited
    nodes_explored = 1

    for move in state.possible_moves():
        new_state = state.apply_move(move)
        new_state_tuple = tuple(map(tuple, new_state.board))

        if new_state_tuple not in visited:
            result, explored = depth_limited_search(new_state, goal_state, depth_limit - 1, visited)
            nodes_explored += explored
            if result is not None:
                return result, nodes_explored

    return None, nodes_explored  # No solution found within depth

def ids(initial_state, goal_state):

    depth = 0
    total_nodes_explored = 0

    while True:
        visited = set()  # Reset visited set for each depth level
        solution, nodes_explored = depth_limited_search(initial_state, goal_state, depth, visited)
        total_nodes_explored += nodes_explored

        if solution is not None:
            return solution, total_nodes_explored  # Found solution

        depth += 1  # Increase depth limit

run_test_1(ids)

run_test_2(ids)

run_test_3(ids)

run_challenge_test_1(ids)

