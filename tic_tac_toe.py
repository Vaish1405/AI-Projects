# -*- coding: utf-8 -*-
"""Tic-Tac-Toe.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1us27IB-4WC_qeEsWGSRa3v1ClOaaExCp
"""

import math
import copy
import random
import time

class TicTacToe:
    def __init__(self):
        self.board = [[' ' for _ in range(3)] for _ in range(3)]
        self.current_winner = None

    def print_board(self):
        for row in self.board:
            print('| ' + ' | '.join(row) + ' |')
        print()

    def available_moves(self):
        return [(r, c) for r in range(3) for c in range(3) if self.board[r][c] == ' ']

    def empty_squares(self):
        return any(' ' in row for row in self.board)

    def make_move(self, r, c, letter):
        if self.board[r][c] == ' ':
            self.board[r][c] = letter
            if self.winner(r, c, letter):
                self.current_winner = letter
            return True
        return False

    def winner(self, r, c, letter):
        if all(self.board[r][i] == letter for i in range(3)):
            return True
        if all(self.board[i][c] == letter for i in range(3)):
            return True
        if r == c and all(self.board[i][i] == letter for i in range(3)):
            return True
        if r + c == 2 and all(self.board[i][2 - i] == letter for i in range(3)):
            return True
        return False

def minimax(board, player, depth=0, stats=None):
    max_player = 'X'
    other_player = 'O' if player == 'X' else 'X'

    if stats is not None:
        stats['nodes_explored'] += 1
        stats['max_depth'] = max(stats['max_depth'], depth)

    if board.current_winner == other_player:
        return {'position': None, 'score': 1 * (10 - depth) if other_player == 'X' else -1 * (10 - depth)}
    elif not board.empty_squares():
        return {'position': None, 'score': 0}

    if player == max_player:
        best = {'position': None, 'score': -math.inf}
    else:
        best = {'position': None, 'score': math.inf}

    for move in board.available_moves():
        r, c = move
        temp_board = copy.deepcopy(board)
        temp_board.make_move(r, c, player)
        sim_score = minimax(temp_board, other_player, depth + 1, stats)

        sim_score['position'] = (r, c)

        if player == max_player:
            if sim_score['score'] > best['score']:
                best = sim_score
        else:
            if sim_score['score'] < best['score']:
                best = sim_score

    return best

def random_move(board):
    moves = board.available_moves()
    return random.choice(moves) if moves else None

def play_game(strategy='best'):
    game = TicTacToe()
    player = 'X'
    steps = 0
    stats = {'nodes_explored': 0, 'max_depth': 0}
    start_time = time.time()

    while game.empty_squares() and not game.current_winner:
        print(f"Step {steps}: Player {player}'s move")
        game.print_board()

        if strategy == 'best':
            move_info = minimax(game, player, stats=stats)
            move = move_info['position']
            best_score = move_info['score']
        elif strategy == 'worst':
            move = random_move(game)
            best_score = None
        else:
            if random.random() < 0.5:
                move_info = minimax(game, player, stats=stats)
                move = move_info['position']
                best_score = move_info['score']
            else:
                move = random_move(game)
                best_score = None

        if move:
            game.make_move(move[0], move[1], player)
            print(f"Player {player} moved to {move}")
            steps += 1

            if game.current_winner:
                print(f"Player {player} wins!")
                game.print_board()
                break

            if not game.empty_squares():
                print("It's a draw!")
                game.print_board()
                break

            player = 'O' if player == 'X' else 'X'

    end_time = time.time()
    return {
        'strategy': strategy,
        'steps': steps,
        'nodes_explored': stats['nodes_explored'],
        'max_depth': stats['max_depth'],
        'execution_time': end_time - start_time,
        'best_score': best_score if strategy != 'worst' else None
    }

def main():
    results = []
    for strategy in ['best', 'worst', 'average']:
        print(f"\n--- {strategy.upper()} Case ---")
        result = play_game(strategy=strategy)
        results.append(result)

    print("\nSummary Table:")
    print("Strategy    | Steps | Nodes Explored | Max Depth | Execution Time (s) | Best Score")
    print("--------------------------------------------------------------------------------------")
    for res in results:
        print(f"{res['strategy'].capitalize():<12} | {res['steps']:^5} | {res['nodes_explored']:^15} | {res['max_depth']:^9} | {res['execution_time']:^19.4f} | {str(res['best_score']):^10}")

    print("\nTime Complexity: O(b^m) where b is branching factor (~9) and m is maximum depth (9).")
    print("Space Complexity: O(bm) for depth of recursion and storage.")

if __name__ == "__main__":
    main()

"""# OLD CODE
Only does the play game features. No performance analysis done.
"""

import math
import copy
import random

class TicTacToe:
    def __init__(self):
        self.board = [[' ' for _ in range(3)] for _ in range(3)]
        self.current_winner = None

    def print_board(self):
        for row in self.board:
            print('| ' + ' | '.join(row) + ' |')
        print()

    def available_moves(self):
        return [(r, c) for r in range(3) for c in range(3) if self.board[r][c] == ' ']

    def empty_squares(self):
        return any(' ' in row for row in self.board)

    def make_move(self, r, c, letter):
        if self.board[r][c] == ' ':
            self.board[r][c] = letter
            if self.winner(r, c, letter):
                self.current_winner = letter
            return True
        return False

    def winner(self, r, c, letter):
        if all(self.board[r][i] == letter for i in range(3)):
            return True
        if all(self.board[i][c] == letter for i in range(3)):
            return True
        if r == c and all(self.board[i][i] == letter for i in range(3)):
            return True
        if r + c == 2 and all(self.board[i][2 - i] == letter for i in range(3)):
            return True
        return False

def minimax(board, player, depth=0):
    max_player = 'X'
    other_player = 'O' if player == 'X' else 'X'

    if board.current_winner == other_player:
        return {'position': None, 'score': 1 * (10 - depth) if other_player == 'X' else -1 * (10 - depth)}
    elif not board.empty_squares():
        return {'position': None, 'score': 0}

    if player == max_player:
        best = {'position': None, 'score': -math.inf}
    else:
        best = {'position': None, 'score': math.inf}

    for move in board.available_moves():
        r, c = move
        temp_board = copy.deepcopy(board)
        temp_board.make_move(r, c, player)
        sim_score = minimax(temp_board, other_player, depth + 1)

        sim_score['position'] = (r, c)

        if player == max_player:
            if sim_score['score'] > best['score']:
                best = sim_score
        else:
            if sim_score['score'] < best['score']:
                best = sim_score

    return best

def random_move(board):
    moves = board.available_moves()
    return random.choice(moves) if moves else None

def play_game(strategy='best'):
    game = TicTacToe()
    player = 'X'
    steps = 0

    while game.empty_squares() and not game.current_winner:
        print(f"Step {steps} - Player {player}'s move:")
        game.print_board()

        if strategy == 'best':
            move = minimax(game, player)['position']
        elif strategy == 'worst':
            move = random_move(game)
        else:  # average
            if random.random() < 0.5:
                move = minimax(game, player)['position']
            else:
                move = random_move(game)

        if move:
            game.make_move(move[0], move[1], player)
            steps += 1

            if game.current_winner:
                print(f"Step {steps} - Player {player} wins!")
                game.print_board()
                return

            if not game.empty_squares():
                print(f"Game ends in a draw after {steps} steps!")
                game.print_board()
                return

            player = 'O' if player == 'X' else 'X'

print("\n--- Best Case (Minimax vs Minimax) ---")
play_game(strategy='best')

print("\n--- Worst Case (Random vs Random) ---")
play_game(strategy='worst')

print("\n--- Average Case (Random and Minimax Mixed) ---")
play_game(strategy='average')

